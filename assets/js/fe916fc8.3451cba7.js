"use strict";(self.webpackChunkavail_docs_wiki=self.webpackChunkavail_docs_wiki||[]).push([[154],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||r;return n?a.createElement(m,l(l({ref:t},u),{},{components:n})):a.createElement(m,l({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(7294),i=n(6010);const r={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(7462),i=n(7294),r=n(6010),l=n(2466),o=n(6550),s=n(1980),c=n(7392),u=n(12);function p(e){return function(e){return i.Children.map(e,(e=>{if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:i}}=e;return{value:t,label:n,attributes:a,default:i}}))}function d(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,o.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(r),(0,i.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=d(e),[l,o]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[s,c]=m({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,u.Nk)(n);return[a,(0,i.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),v=(()=>{const e=s??p;return h({value:e,tabValues:r})?e:null})();(0,i.useLayoutEffect)((()=>{v&&o(v)}),[v]);return{selectedValue:l,selectValue:(0,i.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),f(e)}),[c,f,r]),tabValues:r}}var v=n(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:n,selectedValue:o,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),d=e=>{const t=e.currentTarget,n=u.indexOf(t),a=c[n].value;a!==o&&(p(t),s(a))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:l}=e;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>u.push(e),onKeyDown:h,onClick:d},l,{className:(0,r.Z)("tabs__item",g.tabItem,l?.className,{"tabs__item--active":o===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:a}=e;if(n=Array.isArray(n)?n:[n],t){const e=n.find((e=>e.props.value===a));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},n.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function y(e){const t=f(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",g.tabList)},i.createElement(b,(0,a.Z)({},e,t)),i.createElement(k,(0,a.Z)({},e,t)))}function w(e){const t=(0,v.Z)();return i.createElement(y,(0,a.Z)({key:String(t)},e))}},2666:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));n(4866),n(5162),n(4996);const r={id:"avail-light-client-overview",title:"Light Client Overview",sidebar_label:"Light client overview",sidebar_position:2,description:"Short summary of light client use",keywords:["docs","avail","data","availability","light client","DHT","Kademlia","data sampling"],slug:"avail-light-client-overview"},l=void 0,o={unversionedId:"using-avail/core-sdks-and-apis/avail-light-client-overview",id:"using-avail/core-sdks-and-apis/avail-light-client-overview",title:"Light Client Overview",description:"Short summary of light client use",source:"@site/docs/using-avail/core-sdks-and-apis/using-light-client.md",sourceDirName:"using-avail/core-sdks-and-apis",slug:"/using-avail/core-sdks-and-apis/avail-light-client-overview",permalink:"/using-avail/core-sdks-and-apis/avail-light-client-overview",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"avail-light-client-overview",title:"Light Client Overview",sidebar_label:"Light client overview",sidebar_position:2,description:"Short summary of light client use",keywords:["docs","avail","data","availability","light client","DHT","Kademlia","data sampling"],slug:"avail-light-client-overview"},sidebar:"defaultSidebar",previous:{title:"Communicating With Avail",permalink:"/using-avail/communicating-with-avail"},next:{title:"Embedding the Light Client",permalink:"/using-avail/core-sdks-and-apis/embedding-the-light-client"}},s={},c=[{value:"General concepts",id:"general-concepts",level:2},{value:"Light client",id:"light-client",level:3},{value:"Application client",id:"application-client",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"general-concepts"},"General concepts"),(0,i.kt)("p",null,"Avail light client (LC) lets you interact with Avail blockchain without requiring a full node and without trust assumptions towards remote peers.\nThis is accomplished by leveraging ",(0,i.kt)("strong",{parentName:"p"},"Data Availability Sampling (DAS)")," performed by the light client on every newly created block."),(0,i.kt)("p",null,"The light client listens on the Avail network for finalized blocks and performs DAS on a predetermined number of cells on each new block.\nAfter successful block verification, ",(0,i.kt)("strong",{parentName:"p"},"block confidence")," is calculated for a number of cells in the matrix, with the number depending on the percentage of certainty the users wishes to achieve."),(0,i.kt)("p",null,"Light client functionality is separated into two logical parts - the ",(0,i.kt)("em",{parentName:"p"},"light client")," and the ",(0,i.kt)("em",{parentName:"p"},"app client"),". While the LC is primarily focused on DAS, the app client is used to perform data reconstruction."),(0,i.kt)("h3",{id:"light-client"},"Light client"),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"light client")," mode of operation is active regardless of whether the app client is also active or not.\nLight client connects to an Avail node via a WebSocket connection and waits for a newly finalized block, with the header containing its KZG commitments."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Avail blocks are chunked and divided into equal sized cells as a part of that blocks matrix. Each row in the matrix is then erasure coded using ",(0,i.kt)("strong",{parentName:"p"},"Reed-Solomon (RS)")," erasure codes and committed with ",(0,i.kt)("strong",{parentName:"p"},"Kate-Zaverucha-Goldberg (KZG)")," commitments.")),(0,i.kt)("p",null,"On each received header the client does random sampling of the matrix cells, which are retrieved using one of two mechanisms:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"DHT")," - the client first tries to retrieve cells via Kademlia DHT, on the LC-only high availability peer-to-peer network."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"RPC")," - if some or all of the required cells can't be found on the DHT, LC uses RPC calls to the Avail node(s) to retrieve the data. Cells not already found in the DHT will be uploaded thus increasing blocks availability in the LC P2P network")),(0,i.kt)("p",null,"Once the data is received, light client verifies individual cells and calculates the confidence that is then stored locally."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Light client uses ",(0,i.kt)("em",{parentName:"p"},"libp2p")," with ",(0,i.kt)("strong",{parentName:"p"},"Kademlia")," as a DHT implementation. Peer-to-peer network is able to perform NAT traversal, both symmetric and asymmetric, enabling easy connectivity with various network configurations (e.g. symmetric and asymmetric NAT).")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"On fresh startup, the LC performs a block sync with the node, using both DHT and RPC mechanisms. The block depth to which the sync is going to be done is set with the ",(0,i.kt)("inlineCode",{parentName:"p"},"sync_block_depth")," config parameter, which needs to be set to the max number of blocks the connected node is caching (if downloading via RPC).")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Light client is ",(0,i.kt)("em",{parentName:"p"},"heavily")," customizable with the most important parameters being exposed through its config file, the full config reference can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/availproject/avail-light#config-reference"},"here"),". The default config files for both light and fat client mode of operations can be found bellow."),(0,i.kt)("p",null,"Light client config example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'log_level = "info"\nhttp_server_host = "127.0.0.1"\nhttp_server_port = "7000"\n\nlibp2p_port = "37000"\n\nfull_node_rpc = ["http://127.0.0.1:9933"]\nfull_node_ws = ["ws://127.0.0.1:9944"]\napp_id = 0\nconfidence = 92.0\navail_path = "avail_path"\nprometheus_port = 9520\n# Set to actual bootstrap peer ID and multiaddress\nbootstraps = [["12D3KooWStAKPADXqJ7cngPYXd2mSANpdgh1xQ34aouufHA2xShz", "/ip4/127.0.0.1/tcp/39000"]]\n')),(0,i.kt)("p",null,"For monitoring purposes, ",(0,i.kt)("strong",{parentName:"p"},"Prometheus")," is used."),(0,i.kt)("h3",{id:"application-client"},"Application client"),(0,i.kt)("p",null,"The app client mode is used by individual apps to download, reconstruct and locally store relevant app data.\nApplication data is primarily downloaded from the DHT, either by downloading individual block matrix rows or with per-cell approach, downloading relevant individual cells.\nRPC is (again) used as a fallback mechanisms, if DHT doesn't contain the data."),(0,i.kt)("p",null,"Downloaded and reconstructed data is exposed through a HTTP endpoint, with port configured by the ",(0,i.kt)("inlineCode",{parentName:"p"},"http_server_port")," parameter."),(0,i.kt)("p",null,"App client mode is activated by setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"app_id")," to a value greater than ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"."))}d.isMDXComponent=!0}}]);