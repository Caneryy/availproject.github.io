"use strict";(self.webpackChunkavail_docs_wiki=self.webpackChunkavail_docs_wiki||[]).push([[764],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var i=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)a=o[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),c=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),h=c(a),p=n,m=h["".concat(s,".").concat(p)]||h[p]||u[p]||o;return a?i.createElement(m,l(l({ref:t},d),{},{components:a})):i.createElement(m,l({ref:t},d))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,l=new Array(o);l[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[h]="string"==typeof e?e:n,l[1]=r;for(var c=2;c<o;c++)l[c]=a[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,a)}p.displayName="MDXCreateElement"},8010:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=a(7462),n=(a(7294),a(3905));const o={id:"avail-system-overview",title:"System Overview",sidebar_label:"System Overview",description:"Learn about the architecture of the Avail chain",keywords:["docs","avail","data","availability","architecture"],image:"https://availproject.github.io/img/avail/AvailDocs.png",slug:"avail-system-overview"},l="System Overview",r={unversionedId:"Architecture/avail-system-overview",id:"Architecture/avail-system-overview",title:"System Overview",description:"Learn about the architecture of the Avail chain",source:"@site/docs/Architecture/avail-system-overview.md",sourceDirName:"Architecture",slug:"/Architecture/avail-system-overview",permalink:"/Architecture/avail-system-overview",draft:!1,tags:[],version:"current",frontMatter:{id:"avail-system-overview",title:"System Overview",sidebar_label:"System Overview",description:"Learn about the architecture of the Avail chain",keywords:["docs","avail","data","availability","architecture"],image:"https://availproject.github.io/img/avail/AvailDocs.png",slug:"avail-system-overview"},sidebar:"defaultSidebar",previous:{title:"Consensus",permalink:"/Architecture/avail-consensus"},next:{title:"Run a Light Client",permalink:"/Running Avail/avail-light-client-da"}},s={},c=[{value:"Modularity",id:"modularity",level:2},{value:"Providing data availability",id:"providing-data-availability",level:3},{value:"Enabling the next set of solutions",id:"enabling-the-next-set-of-solutions",level:3},{value:"Validation",id:"validation",level:2},{value:"Peer Validation",id:"peer-validation",level:3},{value:"State verification",id:"state-verification",level:2},{value:"Block verification \u2192 DA verification",id:"block-verification--da-verification",level:3},{value:"Validators",id:"validators",level:4},{value:"Clients",id:"clients",level:4},{value:"Transaction settlement",id:"transaction-settlement",level:3},{value:"Resources",id:"resources",level:2}],d={toc:c},h="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(h,(0,i.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"system-overview"},"System Overview"),(0,n.kt)("h2",{id:"modularity"},"Modularity"),(0,n.kt)("p",null,"Currently, monolithic blockchain architectures like that of Ethereum cannot efficiently handle the execution, settlement, and data availability. "),(0,n.kt)("p",null,"Modularizing execution to scale blockchains is what rollup-centric chain models attempt to do. This can work well when the settlement and data availability layers are on the same layer, which is the approach Ethereum rollups take. Still, there are necessary trade-offs when working with rollups, as the rollup construction can be more secure depending on the security of the data availability layer but would be inherently more challenging to scale."),(0,n.kt)("p",null,"However, a granular design creates different layers to be lightweight protocols, like microservices. Then, the overall network becomes a collection of loosely-coupled lightweight protocols. An example is a data availability layer that only specializes in data availability. Avail is a Substrate-based layer two blockchain for data availability. "),(0,n.kt)("admonition",{title:"Substrate runtime",type:"info"},(0,n.kt)("p",{parentName:"admonition"},"Although Avail is based on the Substrate codebase, it includes modifications to the block structure that prevent it from interoperating with other Substrate networks. Avail implements an independent network unrelated to Polkadot or Kusama.")),(0,n.kt)("p",null,"Avail provides a high guarantee of data availability to any light client, but does not make higher guarantees to light clients about DA than any other network. Avail focuses on making it possible to prove that block data is available without downloading the whole block by leveraging Kate polynomial commitments, erasure coding, and other technologies to allow light clients (which download only the ",(0,n.kt)("em",{parentName:"p"},"headers")," of the chain) to efficiently and randomly sample small amounts of the block data to verify its full availability. However, there are fundamentally different primitives than fraud-proof-based DA systems, which are explained ",(0,n.kt)("a",{parentName:"p",href:"https://blog.availproject.org/the-data-availability-problem/"},"here"),"."),(0,n.kt)("h3",{id:"providing-data-availability"},"Providing data availability"),(0,n.kt)("p",null,"The DA guarantee is something a client determines for itself; it does not have to trust nodes. As the number of light clients grows, they collectively sample the entire block (even though each client only samples a small percentage). Light clients eventually form a P2P network amongst themselves; thus, after a block has been sampled, it becomes highly available \u2014 that is, even if the nodes were to go down (or attempt to censor a block), the light clients would be able to re-construct the block by sharing the pieces amongst themselves."),(0,n.kt)("h3",{id:"enabling-the-next-set-of-solutions"},"Enabling the next set of solutions"),(0,n.kt)("p",null,"Avail will take rollups to the next level as chains can allocate their data availability component to Avail. Avail also provides an alternative way to bootstrap any standalone chain, as chains can offload their data availability. There are, of course, trade-offs that are made with different modularity approaches, but the overall goal is to maintain high security while being able to scale."),(0,n.kt)("p",null,"Transaction costs are also reduced. Avail can grow block size with a smaller impact on the validator workload than a monolithic chain. When a monolithic chain increases block size, validators have to do a lot more work because blocks have to execute, and state has to be calculated. Since Avail has no execution environment, it is much cheaper to increase the block size. The cost is not zero because of the need to calculate KZG commitments and generate proofs, but still inexpensive. "),(0,n.kt)("p",null,"Avail also makes sovereign rollups a possibility. Users can create sovereign chains that rely on Avail's validators to reach consensus on transaction data and order. Sovereign rollups on Avail allow for seamless upgrades, as users can push updates to application-specific nodes to upgrade the chain and, in turn, upgrade to new settlement logic. Whereas in a traditional environment, the network requires a fork."),(0,n.kt)("admonition",{title:"Avail does not have an execution environment",type:"info"},(0,n.kt)("p",{parentName:"admonition"},"Avail does not run smart contracts but allows other chains to make their transaction data available through Avail. These chains may implement their execution environments of any kind: EVM, Wasm, or anything else.")),(0,n.kt)("p",null,"Data availability on Avail is available for a window of time that it is required. For instance, beyond needing data or reconstruction, security is not compromised."),(0,n.kt)("admonition",{title:"Avail doesn't care what the data is for",type:"info"},(0,n.kt)("p",{parentName:"admonition"},"Avail guarantees that block data is available but does not care about what that data is. The data can be transactions but can take on other forms too. ")),(0,n.kt)("p",null,"Storage systems, on the other hand, are designed to store data for long periods, and include incentivization mechanisms to encourage users to store data."),(0,n.kt)("h2",{id:"validation"},"Validation"),(0,n.kt)("h3",{id:"peer-validation"},"Peer Validation"),(0,n.kt)("p",null,"Three types of peers typically compose an ecosystem:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Validator nodes:")," A validator collects transactions from the mempool, executes them, and generates a candidate block that is appended to the network. The block contains a small block header with the digest and metadata of the transactions in the block."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Full nodes:")," The candidate block propagates to full nodes across the network for verification. The nodes will re-execute the transactions contained in the candidate block. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Light clients:")," Light clients only fetch the block header to use for verification and will fetch transaction details from neighboring full nodes as needed.")),(0,n.kt)("p",null,"While a secure approach, Avail addresses the limitations of this architecture to create robustness and increased guarantees. Light clients can be tricked into accepting blocks whose underlying data is unavailable. A block producer can include a malicious transaction in a block and not reveal its entire content to the network. As mentioned in the Avail docs, this is known as the data availability problem."),(0,n.kt)("p",null,"Avail's network peers include:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Validator nodes:")," Protocol incentivized full nodes that participate in the consensus. Validator nodes on Avail do not execute transactions. They package up arbitrary transactions and construct candidate blocks, generating KZG commitments for the data. ",(0,n.kt)("strong",{parentName:"p"},"Other validators check that generated blocks are correct"),".")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Avail (DA) full nodes:")," Nodes that download and make available all block data for all applications using Avail. Similarly, Avail full nodes do not execute transactions.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Avail (DA) light clients:")," Clients that only download block headers randomly sample small parts of the block to verify availability. They expose a local API to interact with the Avail network."))),(0,n.kt)("admonition",{title:"The goal of Avail is not to be reliant on full nodes to keep data available",type:"info"},(0,n.kt)("p",{parentName:"admonition"},"The aim is to give similar DA guarantees to a light client as a full node. Users are encouraged to use Avail light clients. However, they can still run Avail full nodes, which are well supported.")),(0,n.kt)("admonition",{title:"The local API is a WIP and is not yet stable",type:"caution"}),(0,n.kt)("p",null,"This allows applications that want to use Avail to embed the DA light client. They can then build:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"App full nodes")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Embed an Avail (DA) light client"),(0,n.kt)("li",{parentName:"ul"},"Download all data for a specific appID"),(0,n.kt)("li",{parentName:"ul"},"Implement an execution environment to run transactions"),(0,n.kt)("li",{parentName:"ul"},"Maintain application state"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"App light clients")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"Embed an Avail (DA) light client"),(0,n.kt)("li",{parentName:"ul"},"Implement end-user-facing functionality")))),(0,n.kt)("p",null,"The Avail ecosystem will also feature bridges to enable specific use-cases. One such bridge being designed at this time is an ",(0,n.kt)("em",{parentName:"p"},"attestation bridge")," that will post attestations of data available on Avail to Ethereum, thus allowing the creation of validiums."),(0,n.kt)("h2",{id:"state-verification"},"State verification"),(0,n.kt)("h3",{id:"block-verification--da-verification"},"Block verification ","\u2192"," DA verification"),(0,n.kt)("h4",{id:"validators"},"Validators"),(0,n.kt)("p",null,"Instead of Avail validators verifying the application state, they concentrate on ensuring the availability of posted transaction data and providing transaction ordering. A block is considered valid only if the data behind that block is available."),(0,n.kt)("p",null,"Avail validators take on incoming transactions, order them, construct a candidate block, and propose to the network. The block contains special features, especially for DA\u2014erasure coding and KZG commitments. This is in a particular format, so clients can do random sampling and download only a single application's transactions."),(0,n.kt)("p",null,"Other validators verify the block by ensuring the block is well formed, the KZG commitments\ncheck out, the data is there, etc."),(0,n.kt)("h4",{id:"clients"},"Clients"),(0,n.kt)("p",null,"Requiring data to be available prevents block producers from releasing block headers without releasing the data behind them, as this prevents clients from reading the transactions necessary to compute the state of their applications. As with other chains, Avail uses data availability verification to address this through DA checks which utilize erasure codes; these checks are heavily used in data redundancy design."),(0,n.kt)("p",null,"Erasure codes effectively duplicate data so that if part of a block is suppressed, clients can re-construct that part by using another part of the block. This means that a node trying to hide that part would need to hide a lot more."),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"The technique is used in devices like CD-ROMs and multi-disk (RAID) arrays (for instance,\nif a hard drive dies, it can be replaced and re-constructed from the data on other disks).")),(0,n.kt)("p",null,"What is unique about Avail is that the chain design allows ",(0,n.kt)("strong",{parentName:"p"},"anyone")," to check DA without needing to download the data. DA checks require each light client to sample a minimal number of random chunks from each block in the chain. A set of light clients can collectively sample the entire blockchain in this manner. Consequently, the more non-consensus nodes there are, the greater the block size (and throughput) can securely exist. Meaning, non-consensus nodes can contribute to the throughput and security of the network."),(0,n.kt)("h3",{id:"transaction-settlement"},"Transaction settlement"),(0,n.kt)("p",null,"Avail will use a settlement layer built with Polygon Edge. The settlement layer provides an EVM-compatible blockchain for rollups to store their data and perform dispute resolution. The settlement layer utilizes Avail for its DA. When rollups are using a settlement layer, they also inherit all the DA properties of Avail."),(0,n.kt)("admonition",{title:"Different ways to settle",type:"note"},(0,n.kt)("p",{parentName:"admonition"},"There are different ways to use Avail, and the validiums will not use the settlement layer, but rather settle on Ethereum.")),(0,n.kt)("p",null,"Avail offers data hosting and ordering. The execution layer will likely come from multiple off-chain scaling solutions or legacy execution layers. The settlement layer takes on the verification and dispute resolution component."),(0,n.kt)("h2",{id:"resources"},"Resources"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://blog.availproject.org/introducing-avail-by-a-robust-general-purpose-scalable-data-availability-layer/"},"Introduction to Avail"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=okqMT1v3xi0"},"Polygon Talks: Avail"))))}u.isMDXComponent=!0}}]);